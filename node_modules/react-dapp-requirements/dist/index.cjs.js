'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));

var promisify = function promisify(inner) {
    return new Promise(function (resolve, reject) {
        inner(function (error, result) {
            if (error) {
                reject(error);
            }
            resolve(result);
        });
    });
};

var promiseWithTimeout = function promiseWithTimeout(millis, promise) {
    var timeout = new Promise(function (resolve, reject) {
        return setTimeout(function () {
            return reject("promise.timeout");
        }, millis);
    });
    return Promise.race([promise, timeout]);
};

var centeredStyle = {
    "height": "100vh",
    "display": "flex",
    "flex-direction": "column",
    "align-items": "center",
    "justify-content": "center"
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var BrowserUnsupportedScreen = function (_Component) {
    inherits(BrowserUnsupportedScreen, _Component);

    function BrowserUnsupportedScreen() {
        classCallCheck(this, BrowserUnsupportedScreen);
        return possibleConstructorReturn(this, (BrowserUnsupportedScreen.__proto__ || Object.getPrototypeOf(BrowserUnsupportedScreen)).apply(this, arguments));
    }

    createClass(BrowserUnsupportedScreen, [{
        key: "render",
        value: function render() {
            return React__default.createElement(
                "div",
                { style: centeredStyle },
                React__default.createElement(
                    "h1",
                    null,
                    "Your browser is not supported"
                ),
                React__default.createElement(
                    "p",
                    null,
                    "To access the application you need to install Chrome, Firefox, Opera, or Brave"
                )
            );
        }
    }]);
    return BrowserUnsupportedScreen;
}(React.Component);

var CheckForBrowser = function (_Component2) {
    inherits(CheckForBrowser, _Component2);

    function CheckForBrowser() {
        classCallCheck(this, CheckForBrowser);
        return possibleConstructorReturn(this, (CheckForBrowser.__proto__ || Object.getPrototypeOf(CheckForBrowser)).apply(this, arguments));
    }

    createClass(CheckForBrowser, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                BrowserUnsupportedComponent = _props.BrowserUnsupportedComponent,
                isBrowserSupported = _props.isBrowserSupported;

            if (!isBrowserSupported()) {
                return React__default.createElement(BrowserUnsupportedComponent, null);
            }
            return this.props.children;
        }
    }]);
    return CheckForBrowser;
}(React.Component);

CheckForBrowser.propTypes = {
    isBrowserSupported: PropTypes.func.isRequired,
    BrowserUnsupportedComponent: PropTypes.func
};
CheckForBrowser.defaultPros = {
    BrowserUnsupportedComponent: BrowserUnsupportedScreen
};

var Web3UnavailableScreen = function (_Component) {
    inherits(Web3UnavailableScreen, _Component);

    function Web3UnavailableScreen() {
        classCallCheck(this, Web3UnavailableScreen);
        return possibleConstructorReturn(this, (Web3UnavailableScreen.__proto__ || Object.getPrototypeOf(Web3UnavailableScreen)).apply(this, arguments));
    }

    createClass(Web3UnavailableScreen, [{
        key: "render",
        value: function render() {
            return React__default.createElement(
                "div",
                { style: centeredStyle },
                React__default.createElement(
                    "h1",
                    null,
                    "No connection to Ethereum"
                ),
                React__default.createElement(
                    "p",
                    null,
                    "You will need a way to connect and interact with Ethereum through the Browser. The perfect way is Metamask."
                ),
                React__default.createElement(
                    "a",
                    { href: "https://metamask.io", rel: "noopener noreferrer", target: "_blank" },
                    "Install Metamask"
                ),
                React__default.createElement(
                    "p",
                    null,
                    "or ",
                    React__default.createElement(
                        "a",
                        { rel: "noopener noreferrer",
                            href: "https://consensys.zendesk.com/hc/en-us/categories/360000441452-Using-MetaMask",
                            target: "_blank" },
                        "learn more"
                    ),
                    " about Metamask"
                )
            );
        }
    }]);
    return Web3UnavailableScreen;
}(React.Component);

var CheckForWeb3 = function (_Component2) {
    inherits(CheckForWeb3, _Component2);

    function CheckForWeb3() {
        classCallCheck(this, CheckForWeb3);
        return possibleConstructorReturn(this, (CheckForWeb3.__proto__ || Object.getPrototypeOf(CheckForWeb3)).apply(this, arguments));
    }

    createClass(CheckForWeb3, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                Web3UanvailableComponent = _props.Web3UanvailableComponent,
                web3Provided = _props.web3Provided;

            if (!web3Provided()) {
                return React__default.createElement(Web3UnavailableComponent, null);
            }
            return this.props.children;
        }
    }]);
    return CheckForWeb3;
}(React.Component);

CheckForWeb3.propTypes = {
    web3Provided: PropTypes.func.isRequired,
    Web3UnavailableComponent: PropTypes.func
};
CheckForWeb3.defaultProps = {
    Web3UnavailableComponent: Web3UnavailableScreen
};

var NetworkNotSupportedScreen = function (_Component) {
    inherits(NetworkNotSupportedScreen, _Component);

    function NetworkNotSupportedScreen() {
        classCallCheck(this, NetworkNotSupportedScreen);
        return possibleConstructorReturn(this, (NetworkNotSupportedScreen.__proto__ || Object.getPrototypeOf(NetworkNotSupportedScreen)).apply(this, arguments));
    }

    createClass(NetworkNotSupportedScreen, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                currentNetwork = _props.currentNetwork,
                supportedNetworks = _props.supportedNetworks;

            return React__default.createElement(
                "div",
                { style: centeredStyle },
                React__default.createElement(
                    "h1",
                    null,
                    currentNetwork,
                    "  is not supported"
                ),
                React__default.createElement(
                    "p",
                    null,
                    "You must switch to : ",
                    supportedNetworks.join(',')
                )
            );
        }
    }]);
    return NetworkNotSupportedScreen;
}(React.Component);

var NetworkNotFoundScreen = function (_Component2) {
    inherits(NetworkNotFoundScreen, _Component2);

    function NetworkNotFoundScreen() {
        classCallCheck(this, NetworkNotFoundScreen);
        return possibleConstructorReturn(this, (NetworkNotFoundScreen.__proto__ || Object.getPrototypeOf(NetworkNotFoundScreen)).apply(this, arguments));
    }

    createClass(NetworkNotFoundScreen, [{
        key: "render",
        value: function render() {
            return React__default.createElement(
                "div",
                { style: centeredStyle },
                React__default.createElement(
                    "h1",
                    null,
                    "Ethereum network not found"
                ),
                React__default.createElement(
                    "p",
                    null,
                    "Check your internet connection and your Metamask and the reload the application"
                )
            );
        }
    }]);
    return NetworkNotFoundScreen;
}(React.Component);

var LoadingScreen = function (_Component3) {
    inherits(LoadingScreen, _Component3);

    function LoadingScreen() {
        classCallCheck(this, LoadingScreen);
        return possibleConstructorReturn(this, (LoadingScreen.__proto__ || Object.getPrototypeOf(LoadingScreen)).apply(this, arguments));
    }

    createClass(LoadingScreen, [{
        key: "render",
        value: function render() {
            return React__default.createElement(
                "div",
                { style: centeredStyle },
                React__default.createElement(
                    "p",
                    null,
                    "Checking network information"
                )
            );
        }
    }]);
    return LoadingScreen;
}(React.Component);

var CheckForNetwork = function (_Component4) {
    inherits(CheckForNetwork, _Component4);

    function CheckForNetwork(props) {
        classCallCheck(this, CheckForNetwork);

        var _this4 = possibleConstructorReturn(this, (CheckForNetwork.__proto__ || Object.getPrototypeOf(CheckForNetwork)).call(this, props));

        _initialiseProps.call(_this4);

        _this4.state = {
            loading: true,
            hasNetworkConnection: true,
            retries: 0,
            networkId: null
        };
        return _this4;
    }

    createClass(CheckForNetwork, [{
        key: "componentWillMount",
        value: function componentWillMount() {
            this.fetchData();
        }
    }, {
        key: "render",
        value: function render() {
            var _this5 = this;

            var _props2 = this.props,
                NetworkNotSupportedComponent = _props2.NetworkNotSupportedComponent,
                NetworkNotFoundComponent = _props2.NetworkNotFoundComponent,
                LoadingComponent = _props2.LoadingComponent,
                supportedNetworks = _props2.supportedNetworks;

            var isSupportedNetwork = supportedNetworks.length === 0 || supportedNetworks.indexOf(this.state.networkId) >= 0;
            var labelsForSupportedNetworks = supportedNetworks.map(function (networkId) {
                return _this5.getNetworkById(networkId);
            });
            if (this.state.loading) {
                return React__default.createElement(LoadingComponent, null);
            }

            if (!this.state.hasNetworkConnection) {
                return React__default.createElement(NetworkNotFoundComponent, null);
            }

            if (!isSupportedNetwork) {
                return React__default.createElement(NetworkNotSupportedComponent, { currentNetwork: this.getNetworkById(this.state.networkId),
                    supportedNetworks: labelsForSupportedNetworks });
            }
            return this.props.children;
        }
    }]);
    return CheckForNetwork;
}(React.Component);

CheckForNetwork.propTypes = {
    fetchNetwork: PropTypes.func.isRequired,
    networkMap: PropTypes.object.isRequired,
    supportedNetworks: function supportedNetworks(props, propName) {
        if (!Array.isArray(props.supportedNetworks) || !props.supportedNetworks.every(function (prop) {
            return typeof prop === "string";
        })) {
            return new Error(propName + " needs to be an array and contain at least one ETH network id");
        }
        return null;
    },
    onNetworkIdReceived: PropTypes.func,
    NetworkNotSupportedComponent: PropTypes.func,
    LoadingComponent: PropTypes.func,
    NetworkNotFoundComponent: PropTypes.func
};
CheckForNetwork.defaultProps = {
    NetworkNotSupportedComponent: NetworkNotSupportedScreen,
    LoadingComponent: LoadingScreen,
    NetworkNotFoundComponent: NetworkNotFoundScreen,
    numberOfRetries: 3
};

var _initialiseProps = function _initialiseProps() {
    var _this6 = this;

    this.getNetworkById = function (networkId) {
        if (!_this6.props.networkMap.hasOwnProperty(networkId)) return "PRIVATE:" + networkId;
        return _this6.props.networkMap[networkId];
    };

    this.onNetworkIdReceived = function (networkId) {
        if (_this6.props.onNetworkIdReceived) _this6.props.onNetworkIdReceived(networkId);
    };

    this.fetchData = function () {
        try {
            promiseWithTimeout(500, _this6.props.fetchNetwork()).then(function (result) {
                var networkId = result;
                _this6.setState({
                    loading: false,
                    networkId: networkId
                });
                _this6.onNetworkIdReceived(networkId);
            }).catch(function (e) {
                if (_this6.state.retries >= _this6.props.numberOfRetries) {
                    _this6.setState({
                        loading: false,
                        hasNetworkConnection: false
                    });
                    _this6.onNetworkIdReceived(null);
                } else {
                    console.log('retry');
                    _this6.setState({ retries: _this6.state.retries + 1 });
                    _this6.fetchData();
                }
            });
        } catch (e) {
            throw new Error("this.props.fetchNetwork does not return a prommise!");
        }
    };
};

var AccountUnavailableScreen = function (_Component) {
    inherits(AccountUnavailableScreen, _Component);

    function AccountUnavailableScreen() {
        classCallCheck(this, AccountUnavailableScreen);
        return possibleConstructorReturn(this, (AccountUnavailableScreen.__proto__ || Object.getPrototypeOf(AccountUnavailableScreen)).apply(this, arguments));
    }

    createClass(AccountUnavailableScreen, [{
        key: "render",
        value: function render() {
            return React__default.createElement(
                "div",
                { style: centeredStyle },
                React__default.createElement(
                    "h1",
                    null,
                    "Your Metamask is locked"
                ),
                React__default.createElement(
                    "p",
                    null,
                    "Simply open Metamask and follow the instructions to unlock it."
                )
            );
        }
    }]);
    return AccountUnavailableScreen;
}(React.Component);

var LoadingScreen$1 = function (_Component2) {
    inherits(LoadingScreen, _Component2);

    function LoadingScreen() {
        classCallCheck(this, LoadingScreen);
        return possibleConstructorReturn(this, (LoadingScreen.__proto__ || Object.getPrototypeOf(LoadingScreen)).apply(this, arguments));
    }

    createClass(LoadingScreen, [{
        key: "render",
        value: function render() {
            return React__default.createElement(
                "div",
                { style: centeredStyle },
                React__default.createElement(
                    "p",
                    null,
                    "Checking account information"
                )
            );
        }
    }]);
    return LoadingScreen;
}(React.Component);

var CheckForAccount = function (_Component3) {
    inherits(CheckForAccount, _Component3);

    function CheckForAccount(props) {
        classCallCheck(this, CheckForAccount);

        var _this3 = possibleConstructorReturn(this, (CheckForAccount.__proto__ || Object.getPrototypeOf(CheckForAccount)).call(this, props));

        _this3.stopPulling = function () {
            clearInterval(_this3.interval);
            _this3.interval = null;
        };

        _this3.startPulling = function () {
            if (_this3.interval) return;
            _this3.interval = setInterval(_this3.fetchData, _this3.props.pullInterval);
        };

        _this3.onAccountChange = function (account) {
            if (_this3.props.onAccountChange) _this3.props.onAccountChange(account);
        };

        _this3.fetchData = function () {
            try {
                promiseWithTimeout(_this3.props.pullInterval - 50, _this3.props.fetchAccount()).then(function (result) {
                    var selectedAccount = result.shift();
                    console.log('selected Account', selectedAccount);
                    if (selectedAccount !== _this3.state.selectedAccount) {
                        _this3.setState({
                            selectedAccount: selectedAccount,
                            loading: false
                        });
                        console.log('change');
                        _this3.onAccountChange(selectedAccount);
                    }
                }).catch(function (e) {
                    // ignore timeout. We only care about web3 errors
                    if (e !== 'promise.timeout') {
                        _this3.setState({
                            selectedAccount: null,
                            loading: false
                        });
                        _this3.onAccountChange(null);
                    }
                });
            } catch (e) {
                throw new Error("this.props.fetchAccount does not return a prommise!");
            }
        };

        _this3.state = {
            loading: true,
            selectedAccount: null
        };
        return _this3;
    }

    createClass(CheckForAccount, [{
        key: "componentDidMount",
        value: function componentDidMount() {
            this.fetchData();
            this.startPulling();
        }
    }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
            this.stopPulling();
        }
    }, {
        key: "render",
        value: function render() {
            var _props = this.props,
                AccountUnavailableComponent = _props.AccountUnavailableComponent,
                LoadingComponent = _props.LoadingComponent;


            if (this.state.loading) {
                return React__default.createElement(LoadingComponent, null);
            }
            console.log('reder', this.state.selectedAccount);
            if (!this.state.selectedAccount) {
                return React__default.createElement(AccountUnavailableComponent, null);
            }
            return this.props.children;
        }
    }]);
    return CheckForAccount;
}(React.Component);

CheckForAccount.propTypes = {
    fetchAccount: PropTypes.func.isRequired,
    pullInterval: PropTypes.number,
    onAccountChange: PropTypes.func,
    AccountUnavailableComponent: PropTypes.func,
    LoadingComponent: PropTypes.func
};
CheckForAccount.defaultProps = {
    AccountUnavailableComponent: AccountUnavailableScreen,
    LoadingComponent: LoadingScreen$1,
    pullInterval: 500
};

var DappRequirements = function (_Component) {
    inherits(DappRequirements, _Component);

    function DappRequirements() {
        classCallCheck(this, DappRequirements);
        return possibleConstructorReturn(this, (DappRequirements.__proto__ || Object.getPrototypeOf(DappRequirements)).apply(this, arguments));
    }

    createClass(DappRequirements, [{
        key: "render",
        value: function render() {
            //used to skip rendering of components in a test env
            var _window = window,
                bypassChecks = _window.bypassChecks;
            var _props = this.props,
                BrowserUnsupportedComponent = _props.BrowserUnsupportedComponent,
                isBrowserSupported = _props.isBrowserSupported,
                Web3UnavailableComponent = _props.Web3UnavailableComponent,
                web3Provided = _props.web3Provided,
                supportedNetworks = _props.supportedNetworks,
                NetworkNotSupportedComponent = _props.NetworkNotSupportedComponent,
                NetworkLoadingComponent = _props.NetworkLoadingComponent,
                NetworkNotFoundComponent = _props.NetworkNotFoundComponent,
                fetchNetwork = _props.fetchNetwork,
                onNetworkIdReceived = _props.onNetworkIdReceived,
                AccountUnavailableComponent = _props.AccountUnavailableComponent,
                AccountLoadingComponent = _props.AccountLoadingComponent,
                fetchAccount = _props.fetchAccount,
                onAccountChange = _props.onAccountChange;


            return React__default.createElement(
                React__default.Fragment,
                null,
                !bypassChecks ? React__default.createElement(
                    CheckForBrowser,
                    { BrowserUnsupportedComponent: BrowserUnsupportedComponent,
                        isBrowserSupported: isBrowserSupported },
                    React__default.createElement(
                        CheckForWeb3,
                        { Web3UnavailableComponent: Web3UnavailableComponent, web3Provided: web3Provided },
                        React__default.createElement(
                            CheckForNetwork,
                            { LoadingComponent: NetworkLoadingComponent,
                                NetworkNotFoundComponent: NetworkNotFoundComponent,
                                NetworkNotSupportedComponent: NetworkNotSupportedComponent,
                                networkMap: this.props.networkMap,
                                onNetworkIdReceived: onNetworkIdReceived,
                                fetchNetwork: fetchNetwork,
                                supportedNetworks: supportedNetworks },
                            React__default.createElement(
                                CheckForAccount,
                                { AccountUnavailableComponent: AccountUnavailableComponent,
                                    LoadingComponent: AccountLoadingComponent,
                                    fetchAccount: fetchAccount,
                                    onAccountChange: onAccountChange },
                                this.props.children
                            )
                        )
                    )
                ) : this.props.children
            );
        }
    }]);
    return DappRequirements;
}(React.Component);

DappRequirements.propTypes = {
    supportedNetworks: PropTypes.array.isRequired,
    networkMap: PropTypes.object,
    web3Provided: PropTypes.func,
    fetchAccount: PropTypes.func,
    fetchNetwork: PropTypes.func,
    isBrowserSupported: PropTypes.func,
    onNetworkIdReceived: PropTypes.func,
    onAccountChange: PropTypes.func,
    Web3UnavailableComponent: PropTypes.func,
    BrowserUnsupportedComponent: PropTypes.func,
    AccountUnavailableComponent: PropTypes.func,
    AccountLoadingComponent: PropTypes.func,
    NetworkNotSupportedComponent: PropTypes.func,
    NetworkLoadingComponent: PropTypes.func,
    NetworkNotFoundComponent: PropTypes.func
};
DappRequirements.defaultProps = {
    web3Provided: function web3Provided() {
        return window.web3;
    },
    supportedNetworks: [4, 99999],
    isBrowserSupported: function isBrowserSupported() {
        //We support only Firefox, Brave and Chrome as they are the only ones with metamask support
        return navigator.userAgent.match(/(opera|chrome|firefox)\/?\s*(\.?\d+(\.\d+)*)/i);
    },
    fetchAccount: function fetchAccount() {
        var _window2 = window,
            web3 = _window2.web3;

        return promisify(web3.eth.getAccounts);
    },
    fetchNetwork: function fetchNetwork() {
        var _window3 = window,
            web3 = _window3.web3;

        if (typeof web3.version === "string") {
            return web3.eth.net.getId();
        } else if (web3.version.api) {
            return promisify(web3.version.getNetwork);
        }
    },

    networkMap: {
        "1": 'MAINNET',
        "2": 'MORDEN',
        "3": 'ROPSTEN',
        "4": 'RINKEBY',
        "42": 'KOVAN'
    }
};

exports.CheckForBrowser = CheckForBrowser;
exports.CheckForWeb3 = CheckForWeb3;
exports.CheckForNetwork = CheckForNetwork;
exports.CheckForAccount = CheckForAccount;
exports.DappRequirements = DappRequirements;
//# sourceMappingURL=index.cjs.js.map
